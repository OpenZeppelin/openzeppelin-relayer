---
name: Integration Tests
on:
  workflow_dispatch:  # Allow manual triggering from GitHub UI
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for OIDC authentication with AWS
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2  # v2.13.3
        with:
          egress-policy: audit
      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@b5730c660a905a1c1eeea334a4e3b50f9e4a1c0f  # v3.8.0
      - name: Cache Docker layers
        uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57  # v4.2.0
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-integration-${{ hashFiles('**/Cargo.lock', 'Dockerfile.integration') }}
          restore-keys: |
            ${{ runner.os }}-integration-
      - name: Set up AWS credentials via OIDC and role chaining
        uses: ./.github/actions/oidc
        with:
          role-for-oidc: ${{ secrets.ROLE_FOR_OIDC_TESTS }}
          role-to-assume: ${{ secrets.ROLE_TO_ASSUME_TESTS }}
          aws-region: ${{ vars.AWS_REGION_KMS_KEY }}
      - name: Create integration test config
        run: |
          cat > .env.integration << EOF
          MODE=testnet
          API_KEY=${{ secrets.INTEGRATION_TESTS_API_KEY }}
          LOG_LEVEL=info
          USE_KMS=true
          CI=true
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
          AWS_REGION=${{ vars.AWS_REGION_KMS_KEY }}
          EOF
      - name: Inject config files
        env:
          AWS_KMS_REGION: ${{ vars.AWS_REGION_KMS_KEY }}
          AWS_KMS_KEY_ID: ${{ secrets.TESTNET_AWS_KMS_KEY_ID }}
        run: |
          mkdir -p tests/integration/config/testnet
          echo '${{ vars.INTEGRATION_CONFIG_JSON }}' | envsubst > tests/integration/config/testnet/config.json
          echo '${{ vars.INTEGRATION_REGISTRY_JSON }}' > tests/integration/config/testnet/registry.json
      - name: Build Integration Test Image
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355  # v6.10.0
        with:
          context: .
          file: Dockerfile.integration
          target: runtime
          tags: openzeppelin-relayer-integration:latest
          load: true
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
      - name: Create coverage directories
        run: |
          mkdir -p ./coverage ./profraw
          chmod 777 ./coverage ./profraw
      - name: Run Integration Tests
        run: ./scripts/run-integration-docker.sh
      - name: Verify coverage exists
        if: always()
        run: |
          ls -lah ./coverage/
          if [ -f ./coverage/integration-lcov.info ]; then
            echo "✓ Coverage file found ($(wc -l < ./coverage/integration-lcov.info) lines)"
          else
            echo "✗ Coverage file not found!"
            exit 1
          fi
      - name: Upload Integration Coverage to Codecov
        if: always()  # Upload coverage even if tests fail
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7  # v5.5.1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          name: integration-coverage
          files: ./coverage/integration-lcov.info
          flags: integration
          fail_ci_if_error: false
          verbose: true
      - name: Move cache
        if: always()
        run: |-
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
